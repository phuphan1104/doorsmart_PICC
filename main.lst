CCS PCM C Compiler, Version 5.015, 5967               17-Jun-24 11:51

               Filename:   D:\CCS 5.015 Full\PROJECT\2.KHOACUATHONGMINH\codeCT\main.lst

               ROM used:   1868 words (23%)
                           Largest free fragment is 2048
               RAM used:   65 (18%) at main() level
                           84 (23%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   604
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   0B5
.................... #include <main.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0051:  DATA D7,32
0052:  DATA EC,31
0053:  DATA EF,36
0054:  DATA 65,00
0055:  DATA 43,36
0056:  DATA EF,39
0057:  DATA 65,10
0058:  DATA 69,37
0059:  DATA A0,12
005A:  DATA 64,00
005B:  DATA 0A,29
005C:  DATA E5,31
005D:  DATA E5,34
005E:  DATA F6,32
005F:  DATA 64,1D
0060:  DATA A0,12
0061:  DATA 73,05
0062:  DATA 00,00
0063:  DATA 52,23
0064:  DATA 49,22
0065:  DATA A0,31
0066:  DATA 6F,39
0067:  DATA E5,31
0068:  DATA 74,17
0069:  DATA A0,2B
006A:  DATA 65,36
006B:  DATA E3,37
006C:  DATA ED,32
006D:  DATA A1,10
006E:  DATA 21,10
006F:  DATA 0A,00
0070:  DATA 52,23
0071:  DATA 49,22
0072:  DATA 20,27
0073:  DATA 4F,2A
0074:  DATA A0,31
0075:  DATA 6F,39
0076:  DATA E5,31
0077:  DATA 74,17
0078:  DATA 20,05
0079:  DATA 00,01
007A:  DATA 4E,34
007B:  DATA 61,38
007C:  DATA CD,30
007D:  DATA F4,25
007E:  DATA E8,30
007F:  DATA 75,10
0080:  DATA 2A,00
0081:  DATA C4,37
0082:  DATA E9,26
0083:  DATA 61,3A
0084:  DATA 4B,34
0085:  DATA E1,3A
0086:  DATA A0,11
0087:  DATA 00,01
0088:  DATA D8,34
0089:  DATA EE,26
008A:  DATA EF,34
008B:  DATA 4E,34
008C:  DATA 61,38
008D:  DATA CD,25
008E:  DATA 00,01
008F:  DATA C3,37
0090:  DATA F2,32
0091:  DATA 63,3A
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA CE,37
0098:  DATA 74,10
0099:  DATA C3,37
009A:  DATA F2,32
009B:  DATA 63,3A
009C:  DATA 00,01
009D:  DATA CD,30
009E:  DATA F4,25
009F:  DATA E8,30
00A0:  DATA F5,21
00A1:  DATA 75,00
00A2:  DATA CD,30
00A3:  DATA F4,25
00A4:  DATA E8,30
00A5:  DATA F5,26
00A6:  DATA EF,34
00A7:  DATA 00,01
00A8:  DATA CD,25
00A9:  DATA CD,37
00AA:  DATA 69,22
00AB:  DATA 61,26
00AC:  DATA F5,3A
00AD:  DATA 00,01
00AE:  DATA CD,30
00AF:  DATA F4,25
00B0:  DATA E8,30
00B1:  DATA F5,21
00B2:  DATA F5,29
00B3:  DATA E1,34
00B4:  DATA 00,00
*
01E1:  MOVF   0B,W
01E2:  MOVWF  5C
01E3:  BCF    0B.7
01E4:  BSF    03.5
01E5:  BSF    03.6
01E6:  BSF    0C.7
01E7:  BSF    0C.0
01E8:  NOP
01E9:  NOP
01EA:  BCF    03.5
01EB:  BCF    03.6
01EC:  BTFSC  5C.7
01ED:  BSF    0B.7
01EE:  BTFSC  03.0
01EF:  GOTO   219
01F0:  BSF    03.6
01F1:  MOVF   0C,W
01F2:  ANDLW  7F
01F3:  BCF    03.6
01F4:  MOVWF  5C
01F5:  BSF    03.6
01F6:  MOVF   0D,W
01F7:  BCF    03.6
01F8:  MOVWF  5D
01F9:  BSF    03.6
01FA:  MOVF   0F,W
01FB:  BCF    03.6
01FC:  MOVWF  5E
01FD:  MOVF   5C,W
01FE:  BTFSS  0C.4
01FF:  GOTO   1FE
0200:  MOVWF  19
0201:  MOVF   5D,W
0202:  BSF    03.6
0203:  MOVWF  0D
0204:  BCF    03.6
0205:  MOVF   5E,W
0206:  BSF    03.6
0207:  MOVWF  0F
0208:  BCF    03.6
0209:  MOVF   0B,W
020A:  MOVWF  5F
020B:  BCF    0B.7
020C:  BSF    03.5
020D:  BSF    03.6
020E:  BSF    0C.7
020F:  BSF    0C.0
0210:  NOP
0211:  NOP
0212:  BCF    03.5
0213:  BCF    03.6
0214:  BTFSC  5F.7
0215:  BSF    0B.7
0216:  DECFSZ 5B,F
0217:  GOTO   219
0218:  GOTO   239
0219:  BSF    03.6
021A:  RLF    0C,W
021B:  RLF    0E,W
021C:  ANDLW  7F
021D:  BCF    03.6
021E:  MOVWF  5C
021F:  BSF    03.6
0220:  MOVF   0D,W
0221:  BCF    03.6
0222:  MOVWF  5D
0223:  BSF    03.6
0224:  MOVF   0F,W
0225:  BCF    03.6
0226:  MOVWF  5E
0227:  MOVF   5C,W
0228:  BTFSS  0C.4
0229:  GOTO   228
022A:  MOVWF  19
022B:  MOVF   5D,W
022C:  BSF    03.6
022D:  MOVWF  0D
022E:  BCF    03.6
022F:  MOVF   5E,W
0230:  BSF    03.6
0231:  MOVWF  0F
0232:  INCF   0D,F
0233:  BTFSC  03.2
0234:  INCF   0F,F
0235:  BCF    03.0
0236:  BCF    03.6
0237:  DECFSZ 5B,F
0238:  GOTO   1E1
0239:  BCF    0A.3
023A:  BCF    0A.4
023B:  GOTO   665 (RETURN)
023C:  MOVF   00,F
023D:  BTFSC  03.2
023E:  GOTO   252
023F:  CLRF   5C
0240:  MOVF   04,W
0241:  MOVWF  5B
0242:  BCF    5C.0
0243:  BTFSC  03.7
0244:  BSF    5C.0
0245:  MOVF   00,W
0246:  BTFSS  0C.4
0247:  GOTO   246
0248:  MOVWF  19
0249:  MOVF   5B,W
024A:  MOVWF  04
024B:  BCF    03.7
024C:  BTFSC  5C.0
024D:  BSF    03.7
024E:  INCF   04,F
024F:  BTFSC  03.2
0250:  INCF   05,F
0251:  GOTO   23C
0252:  BCF    0A.3
0253:  BCF    0A.4
0254:  GOTO   669 (RETURN)
*
029B:  MOVF   0B,W
029C:  MOVWF  5B
029D:  BCF    0B.7
029E:  BSF    03.5
029F:  BSF    03.6
02A0:  BSF    0C.7
02A1:  BSF    0C.0
02A2:  NOP
02A3:  NOP
02A4:  BCF    03.5
02A5:  BCF    03.6
02A6:  BTFSC  5B.7
02A7:  BSF    0B.7
02A8:  BSF    03.6
02A9:  MOVF   0C,W
02AA:  ANDLW  7F
02AB:  BTFSC  03.2
02AC:  GOTO   2F1
02AD:  BCF    03.6
02AE:  MOVWF  5B
02AF:  BSF    03.6
02B0:  MOVF   0D,W
02B1:  BCF    03.6
02B2:  MOVWF  5C
02B3:  BSF    03.6
02B4:  MOVF   0F,W
02B5:  BCF    03.6
02B6:  MOVWF  5D
02B7:  MOVF   5B,W
02B8:  BTFSS  0C.4
02B9:  GOTO   2B8
02BA:  MOVWF  19
02BB:  MOVF   5C,W
02BC:  BSF    03.6
02BD:  MOVWF  0D
02BE:  BCF    03.6
02BF:  MOVF   5D,W
02C0:  BSF    03.6
02C1:  MOVWF  0F
02C2:  BCF    03.6
02C3:  MOVF   0B,W
02C4:  MOVWF  5E
02C5:  BCF    0B.7
02C6:  BSF    03.5
02C7:  BSF    03.6
02C8:  BSF    0C.7
02C9:  BSF    0C.0
02CA:  NOP
02CB:  NOP
02CC:  BCF    03.5
02CD:  BCF    03.6
02CE:  BTFSC  5E.7
02CF:  BSF    0B.7
02D0:  BSF    03.6
02D1:  RLF    0C,W
02D2:  RLF    0E,W
02D3:  ANDLW  7F
02D4:  BTFSC  03.2
02D5:  GOTO   2F1
02D6:  BCF    03.6
02D7:  MOVWF  5B
02D8:  BSF    03.6
02D9:  MOVF   0D,W
02DA:  BCF    03.6
02DB:  MOVWF  5C
02DC:  BSF    03.6
02DD:  MOVF   0F,W
02DE:  BCF    03.6
02DF:  MOVWF  5D
02E0:  MOVF   5B,W
02E1:  BTFSS  0C.4
02E2:  GOTO   2E1
02E3:  MOVWF  19
02E4:  MOVF   5C,W
02E5:  BSF    03.6
02E6:  MOVWF  0D
02E7:  BCF    03.6
02E8:  MOVF   5D,W
02E9:  BSF    03.6
02EA:  MOVWF  0F
02EB:  INCF   0D,F
02EC:  BTFSC  03.2
02ED:  INCF   0F,F
02EE:  BCF    03.6
02EF:  GOTO   29B
02F0:  BSF    03.6
02F1:  BCF    03.6
02F2:  RETURN
*
0331:  MOVF   0B,W
0332:  MOVWF  5B
0333:  BCF    0B.7
0334:  BSF    03.5
0335:  BSF    03.6
0336:  BSF    0C.7
0337:  BSF    0C.0
0338:  NOP
0339:  NOP
033A:  BCF    03.5
033B:  BCF    03.6
033C:  BTFSC  5B.7
033D:  BSF    0B.7
033E:  BSF    03.6
033F:  MOVF   0C,W
0340:  ANDLW  7F
0341:  BTFSC  03.2
0342:  GOTO   385
0343:  BCF    03.6
0344:  MOVWF  5B
0345:  BSF    03.6
0346:  MOVF   0D,W
0347:  BCF    03.6
0348:  MOVWF  5C
0349:  BSF    03.6
034A:  MOVF   0F,W
034B:  BCF    03.6
034C:  MOVWF  5D
034D:  MOVF   5B,W
034E:  MOVWF  61
034F:  CALL   305
0350:  MOVF   5C,W
0351:  BSF    03.6
0352:  MOVWF  0D
0353:  BCF    03.6
0354:  MOVF   5D,W
0355:  BSF    03.6
0356:  MOVWF  0F
0357:  BCF    03.6
0358:  MOVF   0B,W
0359:  MOVWF  5E
035A:  BCF    0B.7
035B:  BSF    03.5
035C:  BSF    03.6
035D:  BSF    0C.7
035E:  BSF    0C.0
035F:  NOP
0360:  NOP
0361:  BCF    03.5
0362:  BCF    03.6
0363:  BTFSC  5E.7
0364:  BSF    0B.7
0365:  BSF    03.6
0366:  RLF    0C,W
0367:  RLF    0E,W
0368:  ANDLW  7F
0369:  BTFSC  03.2
036A:  GOTO   385
036B:  BCF    03.6
036C:  MOVWF  5B
036D:  BSF    03.6
036E:  MOVF   0D,W
036F:  BCF    03.6
0370:  MOVWF  5C
0371:  BSF    03.6
0372:  MOVF   0F,W
0373:  BCF    03.6
0374:  MOVWF  5D
0375:  MOVF   5B,W
0376:  MOVWF  61
0377:  CALL   305
0378:  MOVF   5C,W
0379:  BSF    03.6
037A:  MOVWF  0D
037B:  BCF    03.6
037C:  MOVF   5D,W
037D:  BSF    03.6
037E:  MOVWF  0F
037F:  INCF   0D,F
0380:  BTFSC  03.2
0381:  INCF   0F,F
0382:  BCF    03.6
0383:  GOTO   331
0384:  BSF    03.6
0385:  BCF    03.6
0386:  RETURN
0387:  MOVF   62,W
0388:  CLRF   78
0389:  SUBWF  61,W
038A:  BTFSC  03.0
038B:  GOTO   38F
038C:  MOVF   61,W
038D:  MOVWF  77
038E:  GOTO   39B
038F:  CLRF   77
0390:  MOVLW  08
0391:  MOVWF  63
0392:  RLF    61,F
0393:  RLF    77,F
0394:  MOVF   62,W
0395:  SUBWF  77,W
0396:  BTFSC  03.0
0397:  MOVWF  77
0398:  RLF    78,F
0399:  DECFSZ 63,F
039A:  GOTO   392
039B:  RETURN
*
03C4:  MOVF   0B,W
03C5:  MOVWF  5C
03C6:  BCF    0B.7
03C7:  BSF    03.5
03C8:  BSF    03.6
03C9:  BSF    0C.7
03CA:  BSF    0C.0
03CB:  NOP
03CC:  NOP
03CD:  BCF    03.5
03CE:  BCF    03.6
03CF:  BTFSC  5C.7
03D0:  BSF    0B.7
03D1:  BTFSC  03.0
03D2:  GOTO   3FB
03D3:  BSF    03.6
03D4:  MOVF   0C,W
03D5:  ANDLW  7F
03D6:  BCF    03.6
03D7:  MOVWF  5C
03D8:  BSF    03.6
03D9:  MOVF   0D,W
03DA:  BCF    03.6
03DB:  MOVWF  5D
03DC:  BSF    03.6
03DD:  MOVF   0F,W
03DE:  BCF    03.6
03DF:  MOVWF  5E
03E0:  MOVF   5C,W
03E1:  MOVWF  61
03E2:  CALL   305
03E3:  MOVF   5D,W
03E4:  BSF    03.6
03E5:  MOVWF  0D
03E6:  BCF    03.6
03E7:  MOVF   5E,W
03E8:  BSF    03.6
03E9:  MOVWF  0F
03EA:  BCF    03.6
03EB:  MOVF   0B,W
03EC:  MOVWF  5F
03ED:  BCF    0B.7
03EE:  BSF    03.5
03EF:  BSF    03.6
03F0:  BSF    0C.7
03F1:  BSF    0C.0
03F2:  NOP
03F3:  NOP
03F4:  BCF    03.5
03F5:  BCF    03.6
03F6:  BTFSC  5F.7
03F7:  BSF    0B.7
03F8:  DECFSZ 5B,F
03F9:  GOTO   3FB
03FA:  GOTO   41A
03FB:  BSF    03.6
03FC:  RLF    0C,W
03FD:  RLF    0E,W
03FE:  ANDLW  7F
03FF:  BCF    03.6
0400:  MOVWF  5C
0401:  BSF    03.6
0402:  MOVF   0D,W
0403:  BCF    03.6
0404:  MOVWF  5D
0405:  BSF    03.6
0406:  MOVF   0F,W
0407:  BCF    03.6
0408:  MOVWF  5E
0409:  MOVF   5C,W
040A:  MOVWF  61
040B:  CALL   305
040C:  MOVF   5D,W
040D:  BSF    03.6
040E:  MOVWF  0D
040F:  BCF    03.6
0410:  MOVF   5E,W
0411:  BSF    03.6
0412:  MOVWF  0F
0413:  INCF   0D,F
0414:  BTFSC  03.2
0415:  INCF   0F,F
0416:  BCF    03.0
0417:  BCF    03.6
0418:  DECFSZ 5B,F
0419:  GOTO   3C4
*
041E:  MOVLW  20
041F:  BTFSS  5C.4
0420:  MOVLW  30
0421:  MOVWF  5D
0422:  MOVF   5B,W
0423:  MOVWF  77
0424:  BTFSS  5B.7
0425:  GOTO   42E
0426:  COMF   77,F
0427:  INCF   77,F
0428:  MOVF   77,W
0429:  MOVWF  5B
042A:  MOVLW  2D
042B:  MOVWF  5D
042C:  BSF    5C.7
042D:  BSF    5C.0
042E:  MOVF   5B,W
042F:  MOVWF  61
0430:  MOVLW  64
0431:  MOVWF  62
0432:  CALL   387
0433:  MOVF   77,W
0434:  MOVWF  5B
0435:  MOVLW  30
0436:  ADDWF  78,W
0437:  MOVWF  5E
0438:  MOVF   5B,W
0439:  MOVWF  61
043A:  MOVLW  0A
043B:  MOVWF  62
043C:  CALL   387
043D:  MOVLW  30
043E:  ADDWF  77,W
043F:  MOVWF  60
0440:  MOVLW  30
0441:  ADDWF  78,W
0442:  MOVWF  5F
0443:  MOVF   5D,W
0444:  MOVWF  77
0445:  MOVLW  30
0446:  SUBWF  5E,W
0447:  BTFSC  03.2
0448:  GOTO   44D
0449:  BSF    5C.1
044A:  BTFSC  5C.7
044B:  BSF    5C.2
044C:  GOTO   461
044D:  MOVF   5D,W
044E:  MOVWF  5E
044F:  MOVLW  20
0450:  MOVWF  5D
0451:  MOVLW  30
0452:  SUBWF  5F,W
0453:  BTFSC  03.2
0454:  GOTO   459
0455:  BSF    5C.0
0456:  BTFSC  5C.7
0457:  BSF    5C.1
0458:  GOTO   461
0459:  BTFSS  03.2
045A:  BSF    5C.0
045B:  BTFSS  03.2
045C:  GOTO   461
045D:  MOVF   5E,W
045E:  MOVWF  5F
045F:  MOVLW  20
0460:  MOVWF  5E
0461:  BTFSC  5C.2
0462:  GOTO   468
0463:  BTFSC  5C.1
0464:  GOTO   46B
0465:  BTFSC  5C.0
0466:  GOTO   46E
0467:  GOTO   471
0468:  MOVF   5D,W
0469:  MOVWF  61
046A:  CALL   305
046B:  MOVF   5E,W
046C:  MOVWF  61
046D:  CALL   305
046E:  MOVF   5F,W
046F:  MOVWF  61
0470:  CALL   305
0471:  MOVF   60,W
0472:  MOVWF  61
0473:  CALL   305
....................  
.................... #list 
....................  
....................  
.................... #device ADC=10 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0255:  MOVF   5C,W
0256:  MOVWF  7A
0257:  MOVF   5B,W
0258:  MOVWF  04
0259:  BCF    03.7
025A:  BTFSC  7A.0
025B:  BSF    03.7
025C:  MOVF   00,W
025D:  MOVWF  5F
025E:  MOVF   5E,W
025F:  MOVWF  7A
0260:  MOVF   5D,W
0261:  MOVWF  04
0262:  BCF    03.7
0263:  BTFSC  7A.0
0264:  BSF    03.7
0265:  MOVF   00,W
0266:  SUBWF  5F,W
0267:  BTFSS  03.2
0268:  GOTO   280
....................       if (*s1 == '\0') 
0269:  MOVF   5C,W
026A:  MOVWF  7A
026B:  MOVF   5B,W
026C:  MOVWF  04
026D:  BCF    03.7
026E:  BTFSC  7A.0
026F:  BSF    03.7
0270:  MOVF   00,F
0271:  BTFSS  03.2
0272:  GOTO   276
....................          return(0); 
0273:  MOVLW  00
0274:  MOVWF  78
0275:  GOTO   298
0276:  MOVF   5C,W
0277:  MOVWF  7A
0278:  MOVF   5B,W
0279:  INCF   5B,F
027A:  BTFSC  03.2
027B:  INCF   5C,F
027C:  INCF   5D,F
027D:  BTFSC  03.2
027E:  INCF   5E,F
027F:  GOTO   255
....................    return((*s1 < *s2) ? -1: 1); 
0280:  MOVF   5C,W
0281:  MOVWF  7A
0282:  MOVF   5B,W
0283:  MOVWF  04
0284:  BCF    03.7
0285:  BTFSC  5C.0
0286:  BSF    03.7
0287:  MOVF   00,W
0288:  MOVWF  5F
0289:  MOVF   5E,W
028A:  MOVWF  7A
028B:  MOVF   5D,W
028C:  MOVWF  04
028D:  BCF    03.7
028E:  BTFSC  5E.0
028F:  BSF    03.7
0290:  MOVF   00,W
0291:  SUBWF  5F,W
0292:  BTFSC  03.0
0293:  GOTO   296
0294:  MOVLW  FF
0295:  GOTO   297
0296:  MOVLW  01
0297:  MOVWF  78
0298:  BCF    0A.3
0299:  BCF    0A.4
029A:  GOTO   674 (RETURN)
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
061A:  BCF    03.5
061B:  CLRF   2B
061C:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(crystal=20000000) 
*
00C8:  MOVLW  62
00C9:  MOVWF  04
00CA:  BCF    03.7
00CB:  MOVF   00,W
00CC:  BTFSC  03.2
00CD:  GOTO   0DB
00CE:  MOVLW  06
00CF:  MOVWF  78
00D0:  CLRF   77
00D1:  DECFSZ 77,F
00D2:  GOTO   0D1
00D3:  DECFSZ 78,F
00D4:  GOTO   0D0
00D5:  MOVLW  7B
00D6:  MOVWF  77
00D7:  DECFSZ 77,F
00D8:  GOTO   0D7
00D9:  DECFSZ 00,F
00DA:  GOTO   0CE
00DB:  RETURN
....................  
....................  
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, parity=N, bits=8) 
.................... //#include<DoorLock.h> 
.................... #define LCD_RS_PIN     PIN_D0 
.................... #define LCD_RW_PIN     PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4      PIN_D4 
.................... #define LCD_DATA5      PIN_D5 
.................... #define LCD_DATA6      PIN_D6 
.................... #define LCD_DATA7      PIN_D7 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0145:  BSF    08.4
....................    output_float(LCD_DATA5); 
0146:  BSF    08.5
....................    output_float(LCD_DATA6); 
0147:  BSF    08.6
....................    output_float(LCD_DATA7); 
0148:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0149:  BCF    03.5
014A:  BSF    08.1
014B:  BSF    03.5
014C:  BCF    08.1
....................    delay_cycles(1); 
014D:  NOP
....................    lcd_output_enable(1); 
014E:  BCF    03.5
014F:  BSF    08.2
0150:  BSF    03.5
0151:  BCF    08.2
....................    delay_cycles(1); 
0152:  NOP
....................    high = lcd_read_nibble(); 
0153:  BCF    03.5
0154:  CALL   10C
0155:  MOVF   78,W
0156:  MOVWF  69
....................        
....................    lcd_output_enable(0); 
0157:  BCF    08.2
0158:  BSF    03.5
0159:  BCF    08.2
....................    delay_cycles(1); 
015A:  NOP
....................    lcd_output_enable(1); 
015B:  BCF    03.5
015C:  BSF    08.2
015D:  BSF    03.5
015E:  BCF    08.2
....................    delay_us(1); 
015F:  GOTO   160
0160:  GOTO   161
0161:  NOP
....................    low = lcd_read_nibble(); 
0162:  BCF    03.5
0163:  CALL   10C
0164:  MOVF   78,W
0165:  MOVWF  68
....................        
....................    lcd_output_enable(0); 
0166:  BCF    08.2
0167:  BSF    03.5
0168:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0169:  BCF    08.4
....................    output_drive(LCD_DATA5); 
016A:  BCF    08.5
....................    output_drive(LCD_DATA6); 
016B:  BCF    08.6
....................    output_drive(LCD_DATA7); 
016C:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
016D:  BCF    03.5
016E:  SWAPF  69,W
016F:  MOVWF  77
0170:  MOVLW  F0
0171:  ANDWF  77,F
0172:  MOVF   77,W
0173:  IORWF  68,W
0174:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
010C:  CLRF   6A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
010D:  BSF    03.5
010E:  BSF    08.4
010F:  MOVLW  00
0110:  BCF    03.5
0111:  BTFSC  08.4
0112:  MOVLW  01
0113:  IORWF  6A,F
....................    n |= input(LCD_DATA5) << 1; 
0114:  BSF    03.5
0115:  BSF    08.5
0116:  MOVLW  00
0117:  BCF    03.5
0118:  BTFSC  08.5
0119:  MOVLW  01
011A:  MOVWF  77
011B:  BCF    03.0
011C:  RLF    77,F
011D:  MOVF   77,W
011E:  IORWF  6A,F
....................    n |= input(LCD_DATA6) << 2; 
011F:  BSF    03.5
0120:  BSF    08.6
0121:  MOVLW  00
0122:  BCF    03.5
0123:  BTFSC  08.6
0124:  MOVLW  01
0125:  MOVWF  77
0126:  RLF    77,F
0127:  RLF    77,F
0128:  MOVLW  FC
0129:  ANDWF  77,F
012A:  MOVF   77,W
012B:  IORWF  6A,F
....................    n |= input(LCD_DATA7) << 3; 
012C:  BSF    03.5
012D:  BSF    08.7
012E:  MOVLW  00
012F:  BCF    03.5
0130:  BTFSC  08.7
0131:  MOVLW  01
0132:  MOVWF  77
0133:  RLF    77,F
0134:  RLF    77,F
0135:  RLF    77,F
0136:  MOVLW  F8
0137:  ANDWF  77,F
0138:  MOVF   77,W
0139:  IORWF  6A,F
....................     
....................    return(n); 
013A:  MOVF   6A,W
013B:  MOVWF  78
....................   #else 
013C:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00DC:  BTFSC  69.0
00DD:  GOTO   0E0
00DE:  BCF    08.4
00DF:  GOTO   0E1
00E0:  BSF    08.4
00E1:  BSF    03.5
00E2:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00E3:  BCF    03.5
00E4:  BTFSC  69.1
00E5:  GOTO   0E8
00E6:  BCF    08.5
00E7:  GOTO   0E9
00E8:  BSF    08.5
00E9:  BSF    03.5
00EA:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00EB:  BCF    03.5
00EC:  BTFSC  69.2
00ED:  GOTO   0F0
00EE:  BCF    08.6
00EF:  GOTO   0F1
00F0:  BSF    08.6
00F1:  BSF    03.5
00F2:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00F3:  BCF    03.5
00F4:  BTFSC  69.3
00F5:  GOTO   0F8
00F6:  BCF    08.7
00F7:  GOTO   0F9
00F8:  BSF    08.7
00F9:  BSF    03.5
00FA:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00FB:  NOP
....................    lcd_output_enable(1); 
00FC:  BCF    03.5
00FD:  BSF    08.2
00FE:  BSF    03.5
00FF:  BCF    08.2
....................    delay_us(2); 
0100:  MOVLW  02
0101:  MOVWF  77
0102:  DECFSZ 77,F
0103:  GOTO   102
0104:  GOTO   105
0105:  NOP
....................    lcd_output_enable(0); 
0106:  BCF    03.5
0107:  BCF    08.2
0108:  BSF    03.5
0109:  BCF    08.2
010A:  BCF    03.5
010B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
013D:  BSF    03.5
013E:  BCF    08.2
....................    lcd_rs_tris(); 
013F:  BCF    08.0
....................    lcd_rw_tris(); 
0140:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0141:  BCF    03.5
0142:  BCF    08.0
0143:  BSF    03.5
0144:  BCF    08.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0175:  MOVF   78,W
0176:  MOVWF  68
0177:  BTFSS  68.7
0178:  GOTO   17B
0179:  BSF    03.5
017A:  GOTO   145
....................    lcd_output_rs(address); 
017B:  MOVF   66,F
017C:  BTFSS  03.2
017D:  GOTO   180
017E:  BCF    08.0
017F:  GOTO   181
0180:  BSF    08.0
0181:  BSF    03.5
0182:  BCF    08.0
....................    delay_cycles(1); 
0183:  NOP
....................    lcd_output_rw(0); 
0184:  BCF    03.5
0185:  BCF    08.1
0186:  BSF    03.5
0187:  BCF    08.1
....................    delay_cycles(1); 
0188:  NOP
....................    lcd_output_enable(0); 
0189:  BCF    03.5
018A:  BCF    08.2
018B:  BSF    03.5
018C:  BCF    08.2
....................    lcd_send_nibble(n >> 4); 
018D:  BCF    03.5
018E:  SWAPF  67,W
018F:  MOVWF  68
0190:  MOVLW  0F
0191:  ANDWF  68,F
0192:  MOVF   68,W
0193:  MOVWF  69
0194:  CALL   0DC
....................    lcd_send_nibble(n & 0xf); 
0195:  MOVF   67,W
0196:  ANDLW  0F
0197:  MOVWF  68
0198:  MOVWF  69
0199:  CALL   0DC
019A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
019B:  MOVLW  28
019C:  MOVWF  5C
019D:  MOVLW  0C
019E:  MOVWF  5D
019F:  MOVLW  01
01A0:  MOVWF  5E
01A1:  MOVLW  06
01A2:  MOVWF  5F
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01A3:  BCF    08.2
01A4:  BSF    03.5
01A5:  BCF    08.2
....................    lcd_output_rs(0); 
01A6:  BCF    03.5
01A7:  BCF    08.0
01A8:  BSF    03.5
01A9:  BCF    08.0
....................    lcd_output_rw(0); 
01AA:  BCF    03.5
01AB:  BCF    08.1
01AC:  BSF    03.5
01AD:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01AE:  BCF    08.4
....................    output_drive(LCD_DATA5); 
01AF:  BCF    08.5
....................    output_drive(LCD_DATA6); 
01B0:  BCF    08.6
....................    output_drive(LCD_DATA7); 
01B1:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01B2:  BCF    08.2
....................    lcd_rs_tris(); 
01B3:  BCF    08.0
....................    lcd_rw_tris(); 
01B4:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
01B5:  MOVLW  0F
01B6:  BCF    03.5
01B7:  MOVWF  62
01B8:  CALL   0C8
....................    for(i=1;i<=3;++i) 
01B9:  MOVLW  01
01BA:  MOVWF  5B
01BB:  MOVF   5B,W
01BC:  SUBLW  03
01BD:  BTFSS  03.0
01BE:  GOTO   1C7
....................    { 
....................        lcd_send_nibble(3); 
01BF:  MOVLW  03
01C0:  MOVWF  69
01C1:  CALL   0DC
....................        delay_ms(5); 
01C2:  MOVLW  05
01C3:  MOVWF  62
01C4:  CALL   0C8
01C5:  INCF   5B,F
01C6:  GOTO   1BB
....................    } 
....................     
....................    lcd_send_nibble(2); 
01C7:  MOVLW  02
01C8:  MOVWF  69
01C9:  CALL   0DC
....................    delay_ms(5); 
01CA:  MOVLW  05
01CB:  MOVWF  62
01CC:  CALL   0C8
....................    for(i=0;i<=3;++i) 
01CD:  CLRF   5B
01CE:  MOVF   5B,W
01CF:  SUBLW  03
01D0:  BTFSS  03.0
01D1:  GOTO   1DE
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01D2:  MOVLW  5C
01D3:  ADDWF  5B,W
01D4:  MOVWF  04
01D5:  BCF    03.7
01D6:  MOVF   00,W
01D7:  MOVWF  60
01D8:  CLRF   66
01D9:  MOVF   60,W
01DA:  MOVWF  67
01DB:  CALL   13D
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01DC:  INCF   5B,F
01DD:  GOTO   1CE
01DE:  BCF    0A.3
01DF:  BCF    0A.4
01E0:  GOTO   64D (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
02F3:  DECFSZ 63,W
02F4:  GOTO   2F6
02F5:  GOTO   2F9
....................       address=LCD_LINE_TWO; 
02F6:  MOVLW  40
02F7:  MOVWF  64
02F8:  GOTO   2FA
....................    else 
....................       address=0; 
02F9:  CLRF   64
....................       
....................    address+=x-1; 
02FA:  MOVLW  01
02FB:  SUBWF  62,W
02FC:  ADDWF  64,F
....................    lcd_send_byte(0,0x80|address); 
02FD:  MOVF   64,W
02FE:  IORLW  80
02FF:  MOVWF  65
0300:  CLRF   66
0301:  MOVF   65,W
0302:  MOVWF  67
0303:  CALL   13D
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0304:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0305:  MOVF   61,W
0306:  XORLW  07
0307:  BTFSC  03.2
0308:  GOTO   313
0309:  XORLW  0B
030A:  BTFSC  03.2
030B:  GOTO   318
030C:  XORLW  06
030D:  BTFSC  03.2
030E:  GOTO   320
030F:  XORLW  02
0310:  BTFSC  03.2
0311:  GOTO   326
0312:  GOTO   32B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0313:  MOVLW  01
0314:  MOVWF  62
0315:  MOVWF  63
0316:  CALL   2F3
0317:  GOTO   330
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0318:  CLRF   66
0319:  MOVLW  01
031A:  MOVWF  67
031B:  CALL   13D
....................                      delay_ms(2); 
031C:  MOVLW  02
031D:  MOVWF  62
031E:  CALL   0C8
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
031F:  GOTO   330
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0320:  MOVLW  01
0321:  MOVWF  62
0322:  MOVLW  02
0323:  MOVWF  63
0324:  CALL   2F3
0325:  GOTO   330
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0326:  CLRF   66
0327:  MOVLW  10
0328:  MOVWF  67
0329:  CALL   13D
032A:  GOTO   330
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
032B:  MOVLW  01
032C:  MOVWF  66
032D:  MOVF   61,W
032E:  MOVWF  67
032F:  CALL   13D
....................      #endif 
....................    } 
0330:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... char received[13]; 
.................... char compare_string[] = "ABCD12FD3B56" ;// RFID 
*
061D:  MOVLW  41
061E:  MOVWF  3A
061F:  MOVLW  42
0620:  MOVWF  3B
0621:  MOVLW  43
0622:  MOVWF  3C
0623:  MOVLW  44
0624:  MOVWF  3D
0625:  MOVLW  31
0626:  MOVWF  3E
0627:  MOVLW  32
0628:  MOVWF  3F
0629:  MOVLW  46
062A:  MOVWF  40
062B:  MOVLW  44
062C:  MOVWF  41
062D:  MOVLW  33
062E:  MOVWF  42
062F:  MOVLW  42
0630:  MOVWF  43
0631:  MOVLW  35
0632:  MOVWF  44
0633:  MOVLW  36
0634:  MOVWF  45
0635:  CLRF   46
.................... int v = 0; 
....................  
.................... int i; 
.................... char matkhau[16]={'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'}; 
0636:  MOVLW  30
0637:  MOVWF  49
0638:  MOVWF  4A
0639:  MOVWF  4B
063A:  MOVWF  4C
063B:  MOVWF  4D
063C:  MOVWF  4E
063D:  MOVWF  4F
063E:  MOVWF  50
063F:  MOVWF  51
0640:  MOVWF  52
0641:  MOVWF  53
0642:  MOVWF  54
0643:  MOVWF  55
0644:  MOVWF  56
0645:  MOVWF  57
0646:  MOVWF  58
....................  
.................... void write_eeprom_pass() 
.................... { 
....................    for(i=0;i<16;i++) 
*
05DB:  CLRF   48
05DC:  MOVF   48,W
05DD:  SUBLW  0F
05DE:  BTFSS  03.0
05DF:  GOTO   601
....................    { 
....................       write_eeprom(i,matkhau[i]); 
05E0:  MOVLW  49
05E1:  ADDWF  48,W
05E2:  MOVWF  04
05E3:  BCF    03.7
05E4:  MOVF   00,W
05E5:  MOVWF  5B
05E6:  MOVF   0B,W
05E7:  MOVWF  77
05E8:  BCF    0B.7
05E9:  MOVF   48,W
05EA:  BSF    03.6
05EB:  MOVWF  0D
05EC:  BCF    03.6
05ED:  MOVF   5B,W
05EE:  BSF    03.6
05EF:  MOVWF  0C
05F0:  BSF    03.5
05F1:  BCF    0C.7
05F2:  BSF    0C.2
05F3:  MOVLW  55
05F4:  MOVWF  0D
05F5:  MOVLW  AA
05F6:  MOVWF  0D
05F7:  BSF    0C.1
05F8:  BTFSC  0C.1
05F9:  GOTO   5F8
05FA:  BCF    0C.2
05FB:  MOVF   77,W
05FC:  BCF    03.5
05FD:  BCF    03.6
05FE:  IORWF  0B,F
05FF:  INCF   48,F
0600:  GOTO   5DC
....................    } 
0601:  BCF    0A.3
0602:  BCF    0A.4
0603:  GOTO   719 (RETURN)
.................... } 
....................  
.................... char keypad() 
.................... { 
....................    output_low(pin_C4); 
*
0484:  BCF    59.4
0485:  MOVF   59,W
0486:  BSF    03.5
0487:  MOVWF  07
0488:  BCF    03.5
0489:  BCF    07.4
....................    output_high(pin_C5); 
048A:  BCF    59.5
048B:  MOVF   59,W
048C:  BSF    03.5
048D:  MOVWF  07
048E:  BCF    03.5
048F:  BSF    07.5
....................    output_high(pin_C3); 
0490:  BCF    59.3
0491:  MOVF   59,W
0492:  BSF    03.5
0493:  MOVWF  07
0494:  BCF    03.5
0495:  BSF    07.3
....................    output_high(pin_C2); 
0496:  BCF    59.2
0497:  MOVF   59,W
0498:  BSF    03.5
0499:  MOVWF  07
049A:  BCF    03.5
049B:  BSF    07.2
....................    if(input(pin_B4)==0) return '7'; 
049C:  BSF    03.5
049D:  BSF    06.4
049E:  BCF    03.5
049F:  BTFSC  06.4
04A0:  GOTO   4A5
04A1:  MOVLW  37
04A2:  MOVWF  78
04A3:  GOTO   572
04A4:  GOTO   4BF
....................    else if(input(pin_B5)==0) return '4'; 
04A5:  BSF    03.5
04A6:  BSF    06.5
04A7:  BCF    03.5
04A8:  BTFSC  06.5
04A9:  GOTO   4AE
04AA:  MOVLW  34
04AB:  MOVWF  78
04AC:  GOTO   572
04AD:  GOTO   4BF
....................    else if(input(pin_B6)==0) return '1'; 
04AE:  BSF    03.5
04AF:  BSF    06.6
04B0:  BCF    03.5
04B1:  BTFSC  06.6
04B2:  GOTO   4B7
04B3:  MOVLW  31
04B4:  MOVWF  78
04B5:  GOTO   572
04B6:  GOTO   4BF
....................    else if(input(pin_B7)==0) return '*'; 
04B7:  BSF    03.5
04B8:  BSF    06.7
04B9:  BCF    03.5
04BA:  BTFSC  06.7
04BB:  GOTO   4BF
04BC:  MOVLW  2A
04BD:  MOVWF  78
04BE:  GOTO   572
....................     
....................    output_high(pin_C4); 
04BF:  BCF    59.4
04C0:  MOVF   59,W
04C1:  BSF    03.5
04C2:  MOVWF  07
04C3:  BCF    03.5
04C4:  BSF    07.4
....................    output_low(pin_C5); 
04C5:  BCF    59.5
04C6:  MOVF   59,W
04C7:  BSF    03.5
04C8:  MOVWF  07
04C9:  BCF    03.5
04CA:  BCF    07.5
....................    output_high(pin_C3); 
04CB:  BCF    59.3
04CC:  MOVF   59,W
04CD:  BSF    03.5
04CE:  MOVWF  07
04CF:  BCF    03.5
04D0:  BSF    07.3
....................    output_high(pin_C2); 
04D1:  BCF    59.2
04D2:  MOVF   59,W
04D3:  BSF    03.5
04D4:  MOVWF  07
04D5:  BCF    03.5
04D6:  BSF    07.2
....................    if(input(pin_B4)==0) return '8'; 
04D7:  BSF    03.5
04D8:  BSF    06.4
04D9:  BCF    03.5
04DA:  BTFSC  06.4
04DB:  GOTO   4E0
04DC:  MOVLW  38
04DD:  MOVWF  78
04DE:  GOTO   572
04DF:  GOTO   4FA
....................    else if(input(pin_B5)==0) return '5'; 
04E0:  BSF    03.5
04E1:  BSF    06.5
04E2:  BCF    03.5
04E3:  BTFSC  06.5
04E4:  GOTO   4E9
04E5:  MOVLW  35
04E6:  MOVWF  78
04E7:  GOTO   572
04E8:  GOTO   4FA
....................    else if(input(pin_B6)==0) return '2'; 
04E9:  BSF    03.5
04EA:  BSF    06.6
04EB:  BCF    03.5
04EC:  BTFSC  06.6
04ED:  GOTO   4F2
04EE:  MOVLW  32
04EF:  MOVWF  78
04F0:  GOTO   572
04F1:  GOTO   4FA
....................    else if(input(pin_B7)==0) return '0'; 
04F2:  BSF    03.5
04F3:  BSF    06.7
04F4:  BCF    03.5
04F5:  BTFSC  06.7
04F6:  GOTO   4FA
04F7:  MOVLW  30
04F8:  MOVWF  78
04F9:  GOTO   572
....................     
....................    output_high(pin_C4); 
04FA:  BCF    59.4
04FB:  MOVF   59,W
04FC:  BSF    03.5
04FD:  MOVWF  07
04FE:  BCF    03.5
04FF:  BSF    07.4
....................    output_high(pin_C5); 
0500:  BCF    59.5
0501:  MOVF   59,W
0502:  BSF    03.5
0503:  MOVWF  07
0504:  BCF    03.5
0505:  BSF    07.5
....................    output_low(pin_C3); 
0506:  BCF    59.3
0507:  MOVF   59,W
0508:  BSF    03.5
0509:  MOVWF  07
050A:  BCF    03.5
050B:  BCF    07.3
....................    output_high(pin_C2); 
050C:  BCF    59.2
050D:  MOVF   59,W
050E:  BSF    03.5
050F:  MOVWF  07
0510:  BCF    03.5
0511:  BSF    07.2
....................    if(input(pin_B4)==0) return '9'; 
0512:  BSF    03.5
0513:  BSF    06.4
0514:  BCF    03.5
0515:  BTFSC  06.4
0516:  GOTO   51B
0517:  MOVLW  39
0518:  MOVWF  78
0519:  GOTO   572
051A:  GOTO   535
....................    else if(input(pin_B5)==0) return '6'; 
051B:  BSF    03.5
051C:  BSF    06.5
051D:  BCF    03.5
051E:  BTFSC  06.5
051F:  GOTO   524
0520:  MOVLW  36
0521:  MOVWF  78
0522:  GOTO   572
0523:  GOTO   535
....................    else if(input(pin_B6)==0) return '3'; 
0524:  BSF    03.5
0525:  BSF    06.6
0526:  BCF    03.5
0527:  BTFSC  06.6
0528:  GOTO   52D
0529:  MOVLW  33
052A:  MOVWF  78
052B:  GOTO   572
052C:  GOTO   535
....................    else if(input(pin_B7)==0) return '#'; 
052D:  BSF    03.5
052E:  BSF    06.7
052F:  BCF    03.5
0530:  BTFSC  06.7
0531:  GOTO   535
0532:  MOVLW  23
0533:  MOVWF  78
0534:  GOTO   572
....................     
....................    output_high(pin_C4); 
0535:  BCF    59.4
0536:  MOVF   59,W
0537:  BSF    03.5
0538:  MOVWF  07
0539:  BCF    03.5
053A:  BSF    07.4
....................    output_high(pin_C5); 
053B:  BCF    59.5
053C:  MOVF   59,W
053D:  BSF    03.5
053E:  MOVWF  07
053F:  BCF    03.5
0540:  BSF    07.5
....................    output_high(pin_C3); 
0541:  BCF    59.3
0542:  MOVF   59,W
0543:  BSF    03.5
0544:  MOVWF  07
0545:  BCF    03.5
0546:  BSF    07.3
....................    output_low(pin_C2); 
0547:  BCF    59.2
0548:  MOVF   59,W
0549:  BSF    03.5
054A:  MOVWF  07
054B:  BCF    03.5
054C:  BCF    07.2
....................    if(input(pin_B4)==0) return 'A'; 
054D:  BSF    03.5
054E:  BSF    06.4
054F:  BCF    03.5
0550:  BTFSC  06.4
0551:  GOTO   556
0552:  MOVLW  41
0553:  MOVWF  78
0554:  GOTO   572
0555:  GOTO   570
....................    else if(input(pin_B5)==0) return 'B'; 
0556:  BSF    03.5
0557:  BSF    06.5
0558:  BCF    03.5
0559:  BTFSC  06.5
055A:  GOTO   55F
055B:  MOVLW  42
055C:  MOVWF  78
055D:  GOTO   572
055E:  GOTO   570
....................    else if(input(pin_B6)==0) return 'C'; 
055F:  BSF    03.5
0560:  BSF    06.6
0561:  BCF    03.5
0562:  BTFSC  06.6
0563:  GOTO   568
0564:  MOVLW  43
0565:  MOVWF  78
0566:  GOTO   572
0567:  GOTO   570
....................    else if(input(pin_B7)==0) return 'D'; 
0568:  BSF    03.5
0569:  BSF    06.7
056A:  BCF    03.5
056B:  BTFSC  06.7
056C:  GOTO   570
056D:  MOVLW  44
056E:  MOVWF  78
056F:  GOTO   572
....................     
....................    return 0xff; 
0570:  MOVLW  FF
0571:  MOVWF  78
0572:  RETURN
.................... } 
....................  
.................... char key_deboucing() 
.................... { 
....................    char key; 
....................    do 
....................    { 
....................       key = keypad();  
*
0582:  CALL   484
0583:  MOVF   78,W
0584:  MOVWF  5D
....................    } while(key==0xff); 
0585:  INCFSZ 5D,W
0586:  GOTO   588
0587:  GOTO   582
....................     
....................    while(keypad()!=0xff); 
0588:  CALL   484
0589:  INCFSZ 78,W
058A:  GOTO   588
....................    return key; 
058B:  MOVF   5D,W
058C:  MOVWF  78
.................... } 
....................  
.................... void enter_pw() 
.................... { 
....................    for(i=0;i<16;i++) 
*
0573:  CLRF   48
0574:  MOVF   48,W
0575:  SUBLW  0F
0576:  BTFSS  03.0
0577:  GOTO   5AD
....................    { 
....................       matkhau[i] = key_deboucing(); 
0578:  MOVLW  49
0579:  ADDWF  48,W
057A:  MOVWF  78
057B:  CLRF   7A
057C:  BTFSC  03.0
057D:  INCF   7A,F
057E:  MOVF   78,W
057F:  MOVWF  5B
0580:  MOVF   7A,W
0581:  MOVWF  5C
*
058D:  MOVF   5B,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  5C.0
0591:  BSF    03.7
0592:  MOVF   78,W
0593:  MOVWF  00
....................       if(matkhau[i]=='#') break; 
0594:  MOVLW  49
0595:  ADDWF  48,W
0596:  MOVWF  04
0597:  BCF    03.7
0598:  MOVF   00,W
0599:  SUBLW  23
059A:  BTFSC  03.2
059B:  GOTO   5AD
....................       lcd_gotoxy(i+1,2); 
059C:  MOVLW  01
059D:  ADDWF  48,W
059E:  MOVWF  5B
059F:  MOVWF  62
05A0:  MOVLW  02
05A1:  MOVWF  63
05A2:  CALL   2F3
....................       printf(lcd_putc,"%c",matkhau[i]); 
05A3:  MOVLW  49
05A4:  ADDWF  48,W
05A5:  MOVWF  04
05A6:  BCF    03.7
05A7:  MOVF   00,W
05A8:  MOVWF  5B
05A9:  MOVWF  61
05AA:  CALL   305
05AB:  INCF   48,F
05AC:  GOTO   574
....................    } 
05AD:  RETURN
.................... } 
....................  
.................... void empty_pw() 
.................... { 
....................    for(i=0;i<16;i++) 
*
05CD:  CLRF   48
05CE:  MOVF   48,W
05CF:  SUBLW  0F
05D0:  BTFSS  03.0
05D1:  GOTO   5DA
....................    { 
....................       matkhau[i]='0';    
05D2:  MOVLW  49
05D3:  ADDWF  48,W
05D4:  MOVWF  04
05D5:  BCF    03.7
05D6:  MOVLW  30
05D7:  MOVWF  00
05D8:  INCF   48,F
05D9:  GOTO   5CE
....................    } 
05DA:  RETURN
.................... } 
....................  
.................... int compare() 
.................... { 
....................    for(i=0;i<16;i++) 
*
05AE:  CLRF   48
05AF:  MOVF   48,W
05B0:  SUBLW  0F
05B1:  BTFSS  03.0
05B2:  GOTO   5CA
....................    { 
....................       if(read_eeprom(i) != matkhau[i]) return 0;    
05B3:  MOVF   48,W
05B4:  BSF    03.6
05B5:  MOVWF  0D
05B6:  BSF    03.5
05B7:  BCF    0C.7
05B8:  BSF    0C.0
05B9:  BCF    03.5
05BA:  MOVF   0C,W
05BB:  BCF    03.6
05BC:  MOVWF  5B
05BD:  MOVLW  49
05BE:  ADDWF  48,W
05BF:  MOVWF  04
05C0:  BCF    03.7
05C1:  MOVF   00,W
05C2:  SUBWF  5B,W
05C3:  BTFSC  03.2
05C4:  GOTO   5C8
05C5:  MOVLW  00
05C6:  MOVWF  78
05C7:  GOTO   5CC
05C8:  INCF   48,F
05C9:  GOTO   5AF
....................    } 
....................    return 1; 
05CA:  MOVLW  01
05CB:  MOVWF  78
05CC:  RETURN
.................... } 
....................  
.................... void open() 
.................... { 
....................    lcd_putc('\f'); 
*
039C:  MOVLW  0C
039D:  MOVWF  61
039E:  CALL   305
....................    lcd_gotoxy(5,1); 
039F:  MOVLW  05
03A0:  MOVWF  62
03A1:  MOVLW  01
03A2:  MOVWF  63
03A3:  CALL   2F3
....................    printf(lcd_putc,"Welcome"); 
03A4:  MOVLW  51
03A5:  BSF    03.6
03A6:  MOVWF  0D
03A7:  MOVLW  00
03A8:  MOVWF  0F
03A9:  BCF    03.6
03AA:  CALL   331
....................    output_high(pin_C0); 
03AB:  BCF    59.0
03AC:  MOVF   59,W
03AD:  BSF    03.5
03AE:  MOVWF  07
03AF:  BCF    03.5
03B0:  BSF    07.0
....................    for(i=9;i>0;i--) 
03B1:  MOVLW  09
03B2:  MOVWF  48
03B3:  MOVF   48,F
03B4:  BTFSC  03.2
03B5:  GOTO   47D
....................    { 
....................       lcd_gotoxy(3,2); 
03B6:  MOVLW  03
03B7:  MOVWF  62
03B8:  MOVLW  02
03B9:  MOVWF  63
03BA:  CALL   2F3
....................       printf(lcd_putc,"Close in %d",i); 
03BB:  MOVLW  55
03BC:  BSF    03.6
03BD:  MOVWF  0D
03BE:  MOVLW  00
03BF:  MOVWF  0F
03C0:  BCF    03.0
03C1:  MOVLW  09
03C2:  BCF    03.6
03C3:  MOVWF  5B
*
041A:  MOVF   48,W
041B:  MOVWF  5B
041C:  MOVLW  18
041D:  MOVWF  5C
....................       delay_ms(1000); 
*
0474:  MOVLW  04
0475:  MOVWF  5B
0476:  MOVLW  FA
0477:  MOVWF  62
0478:  CALL   0C8
0479:  DECFSZ 5B,F
047A:  GOTO   476
047B:  DECF   48,F
047C:  GOTO   3B3
....................    } 
....................    output_low(pin_C0); 
047D:  BCF    59.0
047E:  MOVF   59,W
047F:  BSF    03.5
0480:  MOVWF  07
0481:  BCF    03.5
0482:  BCF    07.0
0483:  RETURN
.................... } 
....................  
.................... void main() 
*
0604:  MOVF   03,W
0605:  ANDLW  1F
0606:  MOVWF  03
0607:  MOVLW  81
0608:  BSF    03.5
0609:  MOVWF  19
060A:  MOVLW  A6
060B:  MOVWF  18
060C:  MOVLW  90
060D:  BCF    03.5
060E:  MOVWF  18
060F:  CLRF   47
0610:  MOVLW  FF
0611:  MOVWF  59
0612:  BSF    03.5
0613:  BSF    1F.0
0614:  BSF    1F.1
0615:  BSF    1F.2
0616:  BCF    1F.3
0617:  MOVLW  07
0618:  MOVWF  1C
0619:  BCF    03.7
.................... { 
....................    enable_interrupts(GLOBAL); 
*
0647:  MOVLW  C0
0648:  IORWF  0B,F
....................    enable_interrupts(INT_RDA); 
0649:  BSF    03.5
064A:  BSF    0C.5
....................  
....................    lcd_init(); 
064B:  BCF    03.5
064C:  GOTO   19B
....................    set_tris_b(0xff); 
064D:  MOVLW  FF
064E:  BSF    03.5
064F:  MOVWF  06
....................    port_b_pullups(true); 
0650:  BCF    01.7
....................  
....................    while(TRUE) 
....................    {   
....................       if(v == 12) { 
0651:  BCF    03.5
0652:  MOVF   47,W
0653:  SUBLW  0C
0654:  BTFSS  03.2
0655:  GOTO   688
....................          received[v] = '\0'; 
0656:  MOVLW  2D
0657:  ADDWF  47,W
0658:  MOVWF  04
0659:  BCF    03.7
065A:  CLRF   00
....................          printf("\nReceived: %s\n", received); 
065B:  MOVLW  5B
065C:  BSF    03.6
065D:  MOVWF  0D
065E:  MOVLW  00
065F:  MOVWF  0F
0660:  BCF    03.0
0661:  MOVLW  0B
0662:  BCF    03.6
0663:  MOVWF  5B
0664:  GOTO   1E1
0665:  MOVLW  2D
0666:  MOVWF  04
0667:  BCF    03.7
0668:  GOTO   23C
0669:  MOVLW  0A
066A:  BTFSS  0C.4
066B:  GOTO   66A
066C:  MOVWF  19
....................          if(strcmp(received, compare_string) == 0) { 
066D:  CLRF   5C
066E:  MOVLW  2D
066F:  MOVWF  5B
0670:  CLRF   5E
0671:  MOVLW  3A
0672:  MOVWF  5D
0673:  GOTO   255
0674:  MOVF   78,F
0675:  BTFSS  03.2
0676:  GOTO   680
....................             printf("RFID corect. Welcome!!! \n"); 
0677:  MOVLW  63
0678:  BSF    03.6
0679:  MOVWF  0D
067A:  MOVLW  00
067B:  MOVWF  0F
067C:  BCF    03.6
067D:  CALL   29B
....................             open(); 
067E:  CALL   39C
....................          } else { 
067F:  GOTO   687
....................             printf("RFID NOT corect. \n"); 
0680:  MOVLW  70
0681:  BSF    03.6
0682:  MOVWF  0D
0683:  MOVLW  00
0684:  MOVWF  0F
0685:  BCF    03.6
0686:  CALL   29B
....................          } 
....................          v = 0;     
0687:  CLRF   47
....................       } 
....................        
....................       lcd_gotoxy(1,1); 
0688:  MOVLW  01
0689:  MOVWF  62
068A:  MOVWF  63
068B:  CALL   2F3
....................       printf(lcd_putc,"NhapMatKhau *"); 
068C:  MOVLW  7A
068D:  BSF    03.6
068E:  MOVWF  0D
068F:  MOVLW  00
0690:  MOVWF  0F
0691:  BCF    03.6
0692:  CALL   331
....................       lcd_gotoxy(1,2); 
0693:  MOVLW  01
0694:  MOVWF  62
0695:  MOVLW  02
0696:  MOVWF  63
0697:  CALL   2F3
....................       printf(lcd_putc,"DoiMatKhau #"); 
0698:  MOVLW  81
0699:  BSF    03.6
069A:  MOVWF  0D
069B:  MOVLW  00
069C:  MOVWF  0F
069D:  BCF    03.6
069E:  CALL   331
....................       char check = keypad(); 
069F:  CALL   484
06A0:  MOVF   78,W
06A1:  MOVWF  5A
....................       delay_ms(300); 
06A2:  MOVLW  02
06A3:  MOVWF  5B
06A4:  MOVLW  96
06A5:  MOVWF  62
06A6:  CALL   0C8
06A7:  DECFSZ 5B,F
06A8:  GOTO   6A4
....................       if(check=='*') 
06A9:  MOVF   5A,W
06AA:  SUBLW  2A
06AB:  BTFSS  03.2
06AC:  GOTO   6F2
....................       { 
....................          lcd_putc('\f'); 
06AD:  MOVLW  0C
06AE:  MOVWF  61
06AF:  CALL   305
....................          lcd_gotoxy(1,1); 
06B0:  MOVLW  01
06B1:  MOVWF  62
06B2:  MOVWF  63
06B3:  CALL   2F3
....................          printf(lcd_putc,"XinMoiNhapMK");  
06B4:  MOVLW  88
06B5:  BSF    03.6
06B6:  MOVWF  0D
06B7:  MOVLW  00
06B8:  MOVWF  0F
06B9:  BCF    03.6
06BA:  CALL   331
....................          enter_pw(); 
06BB:  CALL   573
....................          if(compare()==1) 
06BC:  CALL   5AE
06BD:  DECFSZ 78,W
06BE:  GOTO   6D7
....................          {   
....................             lcd_gotoxy(1,1); 
06BF:  MOVLW  01
06C0:  MOVWF  62
06C1:  MOVWF  63
06C2:  CALL   2F3
....................             printf(lcd_putc,"Corect        "); 
06C3:  MOVLW  8F
06C4:  BSF    03.6
06C5:  MOVWF  0D
06C6:  MOVLW  00
06C7:  MOVWF  0F
06C8:  BCF    03.6
06C9:  CALL   331
....................             empty_pw(); 
06CA:  CALL   5CD
....................             delay_ms(1000); 
06CB:  MOVLW  04
06CC:  MOVWF  5B
06CD:  MOVLW  FA
06CE:  MOVWF  62
06CF:  CALL   0C8
06D0:  DECFSZ 5B,F
06D1:  GOTO   6CD
....................             lcd_putc('\f'); 
06D2:  MOVLW  0C
06D3:  MOVWF  61
06D4:  CALL   305
....................             open(); 
06D5:  CALL   39C
....................          } 
06D6:  GOTO   6F1
....................          else if(compare()==0) 
06D7:  CALL   5AE
06D8:  MOVF   78,F
06D9:  BTFSS  03.2
06DA:  GOTO   6F1
....................          {   
....................             lcd_putc('\f'); 
06DB:  MOVLW  0C
06DC:  MOVWF  61
06DD:  CALL   305
....................             lcd_gotoxy(1,1); 
06DE:  MOVLW  01
06DF:  MOVWF  62
06E0:  MOVWF  63
06E1:  CALL   2F3
....................             printf(lcd_putc,"Not Corect"); 
06E2:  MOVLW  97
06E3:  BSF    03.6
06E4:  MOVWF  0D
06E5:  MOVLW  00
06E6:  MOVWF  0F
06E7:  BCF    03.6
06E8:  CALL   331
....................             empty_pw(); 
06E9:  CALL   5CD
....................             delay_ms(2000); 
06EA:  MOVLW  08
06EB:  MOVWF  5B
06EC:  MOVLW  FA
06ED:  MOVWF  62
06EE:  CALL   0C8
06EF:  DECFSZ 5B,F
06F0:  GOTO   6EC
....................          } 
....................       } 
06F1:  GOTO   74A
....................       else if(check=='#') 
06F2:  MOVF   5A,W
06F3:  SUBLW  23
06F4:  BTFSS  03.2
06F5:  GOTO   74A
....................       { 
....................          lcd_putc('\f'); 
06F6:  MOVLW  0C
06F7:  MOVWF  61
06F8:  CALL   305
....................          lcd_gotoxy(1,1); 
06F9:  MOVLW  01
06FA:  MOVWF  62
06FB:  MOVWF  63
06FC:  CALL   2F3
....................          printf(lcd_putc,"MatKhauCu");  
06FD:  MOVLW  9D
06FE:  BSF    03.6
06FF:  MOVWF  0D
0700:  MOVLW  00
0701:  MOVWF  0F
0702:  BCF    03.6
0703:  CALL   331
....................          enter_pw(); 
0704:  CALL   573
....................          if(compare()==1) 
0705:  CALL   5AE
0706:  DECFSZ 78,W
0707:  GOTO   730
....................          {   
....................             lcd_putc('\f'); 
0708:  MOVLW  0C
0709:  MOVWF  61
070A:  CALL   305
....................             lcd_gotoxy(1,1); 
070B:  MOVLW  01
070C:  MOVWF  62
070D:  MOVWF  63
070E:  CALL   2F3
....................             printf(lcd_putc,"MatKhauMoi"); 
070F:  MOVLW  A2
0710:  BSF    03.6
0711:  MOVWF  0D
0712:  MOVLW  00
0713:  MOVWF  0F
0714:  BCF    03.6
0715:  CALL   331
....................             empty_pw(); 
0716:  CALL   5CD
....................             enter_pw(); 
0717:  CALL   573
....................             write_eeprom_pass(); 
0718:  GOTO   5DB
....................             empty_pw(); 
0719:  CALL   5CD
....................             lcd_putc('\f'); 
071A:  MOVLW  0C
071B:  MOVWF  61
071C:  CALL   305
....................             lcd_gotoxy(1,1); 
071D:  MOVLW  01
071E:  MOVWF  62
071F:  MOVWF  63
0720:  CALL   2F3
....................             printf(lcd_putc,"MKMoiDaLuu"); 
0721:  MOVLW  A8
0722:  BSF    03.6
0723:  MOVWF  0D
0724:  MOVLW  00
0725:  MOVWF  0F
0726:  BCF    03.6
0727:  CALL   331
....................             delay_ms(2000); 
0728:  MOVLW  08
0729:  MOVWF  5B
072A:  MOVLW  FA
072B:  MOVWF  62
072C:  CALL   0C8
072D:  DECFSZ 5B,F
072E:  GOTO   72A
....................          } 
072F:  GOTO   74A
....................          else if(compare()==0) 
0730:  CALL   5AE
0731:  MOVF   78,F
0732:  BTFSS  03.2
0733:  GOTO   74A
....................          {   
....................             lcd_putc('\f'); 
0734:  MOVLW  0C
0735:  MOVWF  61
0736:  CALL   305
....................             lcd_gotoxy(1,1); 
0737:  MOVLW  01
0738:  MOVWF  62
0739:  MOVWF  63
073A:  CALL   2F3
....................             printf(lcd_putc,"MatKhauCuSai"); 
073B:  MOVLW  AE
073C:  BSF    03.6
073D:  MOVWF  0D
073E:  MOVLW  00
073F:  MOVWF  0F
0740:  BCF    03.6
0741:  CALL   331
....................             empty_pw(); 
0742:  CALL   5CD
....................             delay_ms(2000); 
0743:  MOVLW  08
0744:  MOVWF  5B
0745:  MOVLW  FA
0746:  MOVWF  62
0747:  CALL   0C8
0748:  DECFSZ 5B,F
0749:  GOTO   745
....................          } 
....................       } 
074A:  GOTO   652
....................    
....................    } 
....................     
.................... } 
.................... #INT_RDA 
.................... void serial_isr() { 
*
00B5:  BTFSS  0C.5
00B6:  GOTO   0B5
00B7:  MOVF   1A,W
00B8:  MOVWF  6C
*
074B:  SLEEP
....................    char received_char = getc(); 
....................    printf("%c", received_char); 
*
00B9:  MOVF   6C,W
00BA:  BTFSS  0C.4
00BB:  GOTO   0BA
00BC:  MOVWF  19
....................    received[v++] = received_char; 
00BD:  MOVF   47,W
00BE:  INCF   47,F
00BF:  ADDLW  2D
00C0:  MOVWF  04
00C1:  BCF    03.7
00C2:  MOVF   6C,W
00C3:  MOVWF  00
00C4:  BCF    0C.5
00C5:  BCF    0A.3
00C6:  BCF    0A.4
00C7:  GOTO   02D
.................... } 
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
